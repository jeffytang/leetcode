参考：https://lil-q.github.io/2020/04/22/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/

## 概述
贪心算法（greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，
从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。
简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。
动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，
贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，
那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，
贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。

## 流程
1. 创建数学模型来描述问题。
2. 把求解的问题分成若干个子问题。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。

## 题解
回溯算法，动态规划和贪心算法其实是循序渐进的。
回溯算法即是暴力的枚举，每一步对所有可能都进行计算，计算到达终点即返回，
每一步返回后都要把状态回归到之前的状态。
回溯算法的痛点是他有很多重复的计算，解决的办法是引入备忘录，备忘录记录了每一步的结果，
这其实就是子问题的最优解，动态规划由此产生。
所以使用动态规划时必须要满足无后效性，子问题的解一旦确定，就不再改变，
不受在这之后、包含它的更大的问题的求解决策影响。
如果一个问题没有重叠子问题，那就只能使用回溯算法，比如N皇后问题。

对于有些问题，我们通过建立数学模型之后明确知道了子问题的最优解，那么就不需要枚举各种情况了。
比如有 5 元，2 元和 1 元三种硬币无限个，求用这些硬币兑换 x 元的最少硬币个数。
解决这个问题总是先考虑最大面额的硬币，并不需要枚举。
但是对于 5 元，4 元和 1 元这三个面额，贪心算法并不能得出最优解。

